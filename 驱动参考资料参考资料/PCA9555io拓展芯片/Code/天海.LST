C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE 天海
OBJECT MODULE PLACED IN 天海.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 天海.C BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //-----------------------------------------------------------------------------
   2          //PROJECT CODE : 天海短路测试
   3          //CREATE DATE  : 2010.06.25
   4          //CREATED BY   : GaoWei
   5          //FUNCTION     : 多路开短路测试
   6          //部分说明     :
   7          
   8          //-----------------------------------------------------------------------------  
   9          #include <c8051f000.h>                   
  10          #include"intrins.h"  
  11          #include <stdio.h> 
  12          
  13          //定义PCA9555A内部八个寄存器地址
  14          #define PCA9555A_InPutPort0             0x00     //输入端口0  
  15          #define PCA9555A_InPutPort1             0x01     //输入端口1
  16          #define PCA9555A_OutPutPort0      0x02     //输出端口0
  17          #define PCA9555A_OutPutPort1      0x03     //输出端口1
  18          #define PCA9555A_Inversionport0   0x04           //极性反转端口0
  19          #define PCA9555A_Inversionport1   0x05           //极性反转端口1
  20          #define PCA9555A_Configport0                    0x06             //配制端口0
  21          #define PCA9555A_Configport1                    0x07             //配制端口1
  22          
  23          #define  WRITE       0x00                 // WRITE direction bit
  24          #define  READ        0x01                 // READ direction bit
  25          
  26          #define  CHIP_A   0x40                 // Device address for chip A PCA9555DeviceAddress=0x40
  27          #define  CHIP_B   0x42                 // Device address for chip B PCA9555DeviceAddress=0x41
  28          #define  CHIP_C   0x44                 // Device address for chip C PCA9555DeviceAddress=0x42
  29          #define  CHIP_D   0x46                 // Device address for chip D PCA9555DeviceAddress=0x43
  30          #define  CHIP_E   0x48                 // Device address for chip E PCA9555DeviceAddress=0x44
  31          #define  CHIP_F   0x4A                 // Device address for chip F PCA9555DeviceAddress=0x45
  32          //#define  CHIP_G   0x4C                 // Device address for chip G PCA9555DeviceAddress=0x46
  33          //#define  CHIP_H   0x4E                 // Device address for chip H PCA9555DeviceAddress=0x47
  34          
  35          #define  SMB_BUS_ERROR  0x00        // (all modes) BUS ERROR
  36          #define  SMB_START      0x08        // (MT & MR) START transmitted 起始条件已发出
  37          #define  SMB_RP_START   0x10        // (MT & MR) repeated START重复起始条件已发出
  38          #define  SMB_MTADDACK   0x18        // (MT) Slave address + W transmitted;从地址+W已发出，且收到ACK
  39                                              //  ACK received
  40          #define  SMB_MTADDNACK  0x20        // (MT) Slave address + W transmitted;从地址+W已发出，且收到NACK
  41                                              //  NACK received
  42          #define  SMB_MTDBACK    0x28        // (MT) data byte transmitted; ACK rec'vd 数据字节已发出，收到ACK
  43          #define  SMB_MTDBNACK   0x30        // (MT) data byte transmitted; NACK rec'vd数据字节已发出，收到NACK
  44          #define  SMB_MTARBLOST  0x38        // (MT) arbitration lost 竞争失败，保存当前数据
  45          #define  SMB_MRADDACK   0x40        // (MR) Slave address + R transmitted;从地址+R已发出，且收到ACK
  46                                              //  ACK received
  47          #define  SMB_MRADDNACK  0x48        // (MR) Slave address + R transmitted;从地址+R已发出，且收到ACK
  48                                              //  NACK received
  49          #define  SMB_MRDBACK    0x50        // (MR) data byte rec'vd; ACK transmitted数据字节收到，ACK已发出
  50          #define  SMB_MRDBNACK   0x58        // (MR) data byte rec'vd; NACK transmitted数据字节收到，ACK已发出
  51          unsigned char COMMAND;                       // Holds the slave address + R/W bit for
  52          unsigned int WORD,WORDT;                          // Holds data to be transmitted by the SMBus,OR data tha
             -t has just been received.
  53          unsigned char WORDR; 
  54          unsigned char BYTE_NUMBER;          // Used by ISR to check what data has just been, sent - High address b
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 2   

             -yte, Low byte, or data byte
  55          unsigned char RegAdd;
  56          
  57          //----------------------------------------------------------------------------- 
  58          sfr16 TMR3RL   = 0x92;                 // Timer3 reload value
  59          sfr16 TMR3     = 0x94;                 // Timer3 counter
  60          sfr16 ADC0     = 0xbe;                 // ADC0 data
  61          sfr16 ADC0GT   = 0xc4;                 // ADC0 greater than window
  62          sfr16 ADC0LT   = 0xc6;                 // ADC0 less than window 
  63          //-----------------------------------------------------------------------------
  64          bit SM_BUSY;
  65          //LCD控制位
  66          sbit LCD_CS = P3^0;
  67          sbit LCD_DATA = P2^1; 
  68          sbit LCD_SCLK = P1^5;
  69          //启动
  70          sbit Start = P3^3;
  71          //合格LED
  72          sbit Led = P3^2;
  73          //BUZZ
  74          sbit Buzz = P3^1;
  75          //CD4067地址选择位
  76          sbit add_CD4067_A = P1^6;
  77          sbit add_CD4067_B = P1^7;
  78          sbit add_CD4067_C = P3^4;
  79          sbit add_CD4067_D = P3^5;
  80           
  81          
  82          
  83          unsigned char Flag_Short;             //短路标志位
  84          unsigned char Junc_Short,Num_Short;  
  85          unsigned char Channel_Select;   //AD通道
  86          float data adtemp,aaa,xtemp=0;                       //ad临时采样值
  87          
  88          
  89          //-----------------------------------------------------------------------------
  90          void delay1s(unsigned char U);
  91          void delaynms (unsigned int uu);
  92          void delayn_ms (unsigned int uu);
  93          void delay(unsigned char us);
  94          void SYSCLK_Init(void);
  95          void init_lcd (void);
  96          void init_port (void);
  97          void init_int(void);
  98          void init_smbus();
  99          void init_adc();
 100          void rst_smbus();
 101          void SM_Send (unsigned char chip_select, unsigned char byte_address, unsigned int out_byte);
 102          char SM_Receive (unsigned char chip_select, unsigned char byte_address);
 103          void SMBus_ISR (void);
 104          void wr_lcd (unsigned char  dat_comm,unsigned char content);
 105          void dis_eng(const unsigned char *eng,unsigned char row,unsigned char colum,unsigned char data_size);
 106          void dis_chn (const unsigned char *chn,unsigned char row,unsigned char colum,unsigned char data_size);
 107          void myshow(float testdata, unsigned char showadd);              //测试数据实时显示
 108          void myshow_ShortPin(float testdata, unsigned char showadd);     //测试短路引脚号实时显示
 109          void Buzz100ms(unsigned char u);   //蜂鸣器短
 110          void Buzz1s(unsigned char uuu);    //蜂鸣器长
 111          void ADC (unsigned char Channel);
 112          void TstShort(float x1,float x2);
 113          void Clear();
 114          
 115          
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 3   

 116          //-----------------------------------------------------------------------------
 117          main()  
 118          {   
 119   1              float uu=1;
 120   1          
 121   1        WDTCN = 0xde;
 122   1        WDTCN = 0xad;
 123   1        SYSCLK_Init();              //初始化时钟
 124   1        init_int();
 125   1        init_port (); 
 126   1        init_lcd();
 127   1        init_smbus();
 128   1        init_adc();
 129   1        //delaynms(10); 
 130   1        
 131   1         
 132   1       
 133   1        dis_chn((const unsigned char *)"长城", 1, 1, 2); 
 134   1              dis_eng((const unsigned char *)"M11", 1, 3, 3);
 135   1        dis_chn((const unsigned char *)"短路测试", 2, 3, 4); 
 136   1        dis_chn((const unsigned char *)"上海沪工", 4, 5, 4);  
 137   1        
 138   1      while(1)
 139   1        {  
 140   2      //      if(!(Start))
 141   2      //      {
 142   2               
 143   2              
 144   2               Clear();
 145   2               wr_lcd (0,0x01);  /*清屏，地址指针指向00H*/ 
 146   2               dis_chn((const unsigned char *)"测试中。。。", 1, 1, 6);
 147   2               dis_chn((const unsigned char *)"上海沪工", 4, 5, 4); 
 148   2              
 149   2               
 150   2           SM_Send(CHIP_A,PCA9555A_Configport0,0x0000);   //A输出 
 151   2           SM_Send(CHIP_B,PCA9555A_Configport0,0x0000);   //B输出 
 152   2           SM_Send(CHIP_C,PCA9555A_Configport0,0x0000);   //C输出 
 153   2           SM_Send(CHIP_D,PCA9555A_Configport0,0x0000);   //D输出
 154   2           SM_Send(CHIP_E,PCA9555A_Configport0,0x0000);   //E输出 
 155   2           SM_Send(CHIP_F,PCA9555A_Configport0,0x0000);   //F输出 
 156   2           delaynms(2);
 157   2      
 158   2      
 159   2       //SM_Send(CHIP_A,PCA9555A_OutPutPort0,0xffff);   //写1恢复A片全1
 160   2       // SM_Send(CHIP_B,PCA9555A_OutPutPort0,0xffff);   //写1恢复B片全1
 161   2       //SM_Send(CHIP_C,PCA9555A_OutPutPort0,0xffff);   //写1恢复C片全1
 162   2        //SM_Send(CHIP_D,PCA9555A_OutPutPort0,0xffff);   //写1恢复D片全1
 163   2        _nop_(); 
 164   2          
 165   2      //SM_Send(CHIP_E,PCA9555A_OutPutPort0,0xffff);   //写1恢复E片全1
 166   2           
 167   2       
 168   2      //SM_Send(CHIP_F,PCA9555A_OutPutPort0,0xffff);   //写1恢复F片全1
 169   2           
 170   2      //     SM_Send(CHIP_A,PCA9555A_Configport0,0xfeff);   //输入
 171   2      //     delaynms(10);
 172   2      //     SM_Receive (CHIP_A, PCA9555A_InPutPort0);
 173   2      //     WORDR = WORDR;    
 174   2           
 175   2           
 176   2       
 177   2        
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 4   

 178   2      
 179   2       
 180   2      }               
 181   1      //} 
 182   1      }
 183          
 184          //-----------------------------------------------------------------------------
 185          void delay(unsigned char us)
 186          {
 187   1              while (us)
 188   1              {  _nop_();
 189   2                        --us;
 190   2              }
 191   1      }
 192          //-----------------------------------------------------------------------------
 193          void SYSCLK_Init(void)
 194          {  int i;                              // delay counter
 195   1               OSCXCN = 0x67;                      // start external oscillator with
 196   1                                             // 4MHz crystal
 197   1         for (i=0; i < 256; i++) ;           // Wait for osc. to start up
 198   1         while (!(OSCXCN & 0x80)) ;  
 199   1         OSCICN = 0x88;                      // select external oscillator as SYSCLK
 200   1                                             // source and enable missing clock
 201   1                                             // detector
 202   1                                             //       OSCICN = 0x07;   //interal 16MHZ
 203   1                                  
 204   1      }
 205          //------------------------------------------------------------------------------
 206          void init_port (void) 
 207          {   XBR0  = 0x01;     //使能SMBUS
 208   1                XBR2  = 0x40;
 209   1               
 210   1                PRT0CF = 0Xff; 
 211   1                PRT1CF = 0Xff;
 212   1                PRT2CF = 0Xff;
 213   1                PRT3CF = 0X00; 
 214   1              }
 215          //------------------------------------------------------------------------------------------
 216          void init_smbus()    //SDA=P0.0  SCL=P0.1
 217          {
 218   1      //    SMB0CN    = 0x00;                       //禁止ＳＭｂｕｓ 
 219   1      //    SM_BUSY = 0;
 220   1          SMB0CN    = 0x40;                         //允许ＳＭｂｕｓ
 221   1          SMB0CR    = 0x99;                                             //系统时钟为100KHZ
 222   1      
 223   1      }
 224          //------------------------------------------------------------------------------------------
 225          //void init_adc()
 226          //{
 227          //      AMX0CF = 0x00;  // AMUX  配置差动/单端方式 
 228          //      ADC0CN = 0x80;  // ADC Control Register
 229          //      ADC0CF = 0x00;  // 增益1倍，转换时间系统时钟1个
 230          //       
 231          //       REF0CN = 0x03;  
 232          //   ADC0CN |= 0x80; // 
 233          //      }
 234          //------------------------------------------------------------------------------------------
 235          void rst_smbus()
 236          {
 237   1          SMB0CN    = 0x00;                         //禁止ＳＭｂｕｓ 
 238   1          SMB0CN    = 0x40;                         //允许ＳＭｂｕｓ
 239   1          SMB0CR    = 0x99;                                             //系统时钟为100KHZ
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 5   

 240   1      
 241   1      }
 242          //------------------------------------------------------------------------------
 243          void init_lcd (void)
 244          {
 245   1        delayn_ms (3);
 246   1        wr_lcd (0,0x30);  /*30---基本指令动作*/ 
 247   1        wr_lcd (0,0x01);  /*清屏，地址指针指向00H*/
 248   1        delayn_ms (3);
 249   1        wr_lcd (0,0x06);  /*光标的移动方向*/
 250   1        wr_lcd (0,0x0c);  /*开显示，关游标*/ 
 251   1      }
 252          //-------------------------------------------------------------------------------------------
 253          //*chn:the chinese arrary
 254          //row:1-4
 255          //colum:1-8
 256          //data_size:1-16
 257          //
 258          //-------------------------------------------------------------------------------------------
 259          void dis_eng(const unsigned char *eng,unsigned char row,unsigned char colum,unsigned char data_size)
 260          {const unsigned char *i = 0;
 261   1              if (!(data_size < 17 && row < 5 && colum < 9)) return;
 262   1            i=data_size+eng;
 263   1              wr_lcd (0,0x30);
 264   1              if (row < 3) wr_lcd(0,0x80+((row-1)*16+(colum-1)));
 265   1              else wr_lcd(0,0x88+((row-3)*16+(colum-1)));
 266   1              while(eng!=i)wr_lcd (1,*eng++);
 267   1      }
 268          //-------------------------------------------------------------------------------------------
 269          //*chn:the chinese arrary
 270          //row:1-4
 271          //colum:1-8
 272          //data_size:1-8
 273          //
 274          //------------------------------------------------------------------------------------------
 275          void dis_chn (const unsigned char *chn,unsigned char row,unsigned char colum,unsigned char data_size)
 276          {const unsigned char *i = 0;
 277   1                if(!(data_size < 9 && row < 5 && colum < 9)) return;
 278   1                i=data_size*2+chn;
 279   1                wr_lcd (0,0x30);
 280   1                if (row<3) wr_lcd(0,0x80+((row-1)*16+(colum-1)));
 281   1                else  wr_lcd(0,0x88+((row-3)*16+(colum-1)));
 282   1                while(chn!=i) wr_lcd (1,*chn++);
 283   1      }
 284          //------------------------------------------------------------------------------
 285          void wr_lcd (unsigned char  dat_comm,unsigned char content)
 286          {
 287   1        unsigned char a,i,j;
 288   1        delayn_ms(5);
 289   1        a=content;
 290   1        LCD_CS = 1;   //GPIOPinWrite(GPIO_PORTB_BASE, LCD_CS, LCD_CS);//pb1,pin11,u2
 291   1        LCD_DATA = 1; //GPIOPinWrite(GPIO_PORTB_BASE, LCD_DATA, LCD_DATA);//pb0,pin14,u2
 292   1        LCD_SCLK = 0; //GPIOPinWrite(GPIO_PORTB_BASE, LCD_SCLK, ~LCD_SCLK);//pb2,pin12,u2
 293   1        delayn_ms(1);
 294   1        for(i=0;i<5;i++)///1 1 1 1 1
 295   1        {
 296   2          delayn_ms(1);
 297   2          LCD_SCLK = 1; //GPIOPinWrite(GPIO_PORTB_BASE, LCD_SCLK, LCD_SCLK);
 298   2          delayn_ms(1);
 299   2          LCD_SCLK = 0; //GPIOPinWrite(GPIO_PORTB_BASE, LCD_SCLK, ~LCD_SCLK);
 300   2        }
 301   1        LCD_DATA = 0;   //GPIOPinWrite(GPIO_PORTB_BASE, LCD_DATA, ~LCD_DATA);///rw 0
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 6   

 302   1        delayn_ms(1);
 303   1        LCD_SCLK = 1;   //GPIOPinWrite(GPIO_PORTB_BASE, LCD_SCLK, LCD_SCLK);
 304   1        delayn_ms(1);
 305   1        LCD_SCLK = 0;   //GPIOPinWrite(GPIO_PORTB_BASE, LCD_SCLK, ~LCD_SCLK);
 306   1        if(dat_comm)//rs
 307   1          {LCD_DATA = 1;}//GPIOPinWrite(GPIO_PORTB_BASE, LCD_DATA, LCD_DATA);   //data
 308   1        else LCD_DATA = 0; //GPIOPinWrite(GPIO_PORTB_BASE, LCD_DATA, ~LCD_DATA);   //command
 309   1        delayn_ms(1);
 310   1        LCD_SCLK = 1;   //GPIOPinWrite(GPIO_PORTB_BASE, LCD_SCLK, LCD_SCLK);
 311   1        delayn_ms(1);
 312   1        LCD_SCLK = 0;   //GPIOPinWrite(GPIO_PORTB_BASE, LCD_SCLK, ~LCD_SCLK);
 313   1        LCD_DATA = 0;   //GPIOPinWrite(GPIO_PORTB_BASE, LCD_DATA, ~LCD_DATA);///0
 314   1       delayn_ms(1);
 315   1        LCD_SCLK = 1;   //GPIOPinWrite(GPIO_PORTB_BASE, LCD_SCLK, LCD_SCLK);
 316   1       delayn_ms(1);
 317   1        LCD_SCLK = 0;   //GPIOPinWrite(GPIO_PORTB_BASE, LCD_SCLK, ~LCD_SCLK);
 318   1        for(j=0;j<2;j++)
 319   1        {
 320   2          for(i=0;i<4;i++)
 321   2          {
 322   3           if (a&0x80)
 323   3              {LCD_DATA = 1;}
 324   3              else LCD_DATA = 0;
 325   3           //GPIOPinWrite(GPIO_PORTB_BASE, LCD_DATA, a&0x80? LCD_DATA:(unsigned char)~LCD_DATA); 
 326   3           delayn_ms(1);
 327   3           LCD_SCLK = 1; //GPIOPinWrite(GPIO_PORTB_BASE, LCD_SCLK, LCD_SCLK);
 328   3           delayn_ms(1);
 329   3           LCD_SCLK = 0;//GPIOPinWrite(GPIO_PORTB_BASE, LCD_SCLK, ~LCD_SCLK);
 330   3           a=a<<1;
 331   3          }
 332   2          LCD_DATA = 0;  //GPIOPinWrite(GPIO_PORTB_BASE, LCD_DATA, ~LCD_DATA);///0
 333   2          delayn_ms(1);
 334   2          for(i=0;i<4;i++)///0 0 0 0
 335   2          {
 336   3            LCD_SCLK = 1; //GPIOPinWrite(GPIO_PORTB_BASE, LCD_SCLK, LCD_SCLK);
 337   3              delayn_ms(1);
 338   3              LCD_SCLK = 0; //GPIOPinWrite(GPIO_PORTB_BASE, LCD_SCLK, ~LCD_SCLK);
 339   3          }
 340   2        }
 341   1      }
 342          //-----------------------------------------------------------------------------
 343          void init_int(void)
 344          {   IE        = 0x80; 
 345   1          EIE1      = 0x02;
 346   1           EIP2      = 0x02;    //AD优先 
 347   1          EA = 1; 
 348   1      }
 349          //-----------------------------------------------------------------------------
 350          // SMBus random read function------------------------------------------------------
 351          // Reads 1 byte from the specified memory location.
 352          //
 353          // byte_address = memory address of byte to read
 354          // chip_select = device address of EEPROM to be read from
 355          char SM_Receive (unsigned char chip_select, unsigned char byte_address)
 356          {
 357   1         while (SM_BUSY);                          // Wait for bus to be free.
 358   1         SM_BUSY = 1;                              // Occupy SMBus (set to busy)
 359   1          //SFRPAGE   = SMB0_PAGE;
 360   1         SMB0CN = 0x44;                            // SMBus enabled, ACK on acknowledge cycle
 361   1      
 362   1         BYTE_NUMBER = 2;                          // 2 address bytes
 363   1         COMMAND = (chip_select | READ);           // Chip select + READ
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 7   

 364   1         RegAdd = byte_address;
 365   1         
 366   1         //SFRPAGE   = SMB0_PAGE;
 367   1         STO = 0;
 368   1         STA = 1;                                  // Start transfer
 369   1         
 370   1         while (SM_BUSY);          
 371   1         return WORD;
 372   1      }
 373          //------------------------------------------------------------------------------------------
 374          void SM_Send (unsigned char chip_select, unsigned char byte_address, unsigned int out_byte)
 375          //out_byte为16位，高8位写P0，低8位些P1
 376          {
 377   1          while (SM_BUSY);                          // Wait for SMBus to be free.
 378   1          SM_BUSY = 1;                              // Occupy SMBus (set to busy)
 379   1          //SFRPAGE   = SMB0_PAGE;
 380   1          SMB0CN = 0x44;                            // SMBus enabled,
 381   1                                                   // ACK on acknowledge cycle 
 382   1      
 383   1         BYTE_NUMBER = 2;                          // 2 address bytes.
 384   1         COMMAND = (chip_select | WRITE);  
 385   1         RegAdd = byte_address;
 386   1         WORD = out_byte;
 387   1         
 388   1         //SFRPAGE   = SMB0_PAGE;
 389   1         STO = 0;
 390   1         STA = 1;                                  // Start transfer
 391   1        
 392   1      }
 393          //------------------------------------------------------------------------------------
 394          // Interrupt Service Routine
 395          //------------------------------------------------------------------------------------
 396          void SMBUS_ISR (void) interrupt 7
 397          {
 398   1         switch (SMB0STA){                   // Status code for the SMBus (SMB0STA register)
 399   2      
 400   2            // Master Transmitter/Receiver: START condition transmitted.
 401   2            // The R/W bit of the COMMAND word sent after this state will
 402   2            // always be a zero (W) because for both read and write,
 403   2            // the memory address must be written first.
 404   2            case SMB_START:
 405   2                //SFRPAGE   = SMB0_PAGE;
 406   2      //           if (COMMAND & 0x01){    // If R/W=READ, sent repeated START.
 407   2      //                SMB0DAT = COMMAND;   // Load address of the slave to be accessed.
 408   2      //           } else
 409   2                            SMB0DAT = (COMMAND & 0xFE);   // Load address of the slave to be accessed.
 410   2                STA = 0;                      // Manually clear START bit
 411   2                break;
 412   2      
 413   2            // Master Transmitter/Receiver: Repeated START condition transmitted.
 414   2            // This state should only occur during a read, after the memory address has been
 415   2            // sent and acknowledged.
 416   2            case SMB_RP_START:
 417   2               //SFRPAGE   = SMB0_PAGE;
 418   2                           SMB0DAT = COMMAND;            // COMMAND should hold slave address + R.
 419   2               STA = 0;
 420   2               break;
 421   2      
 422   2            // Master Transmitter: Slave address + WRITE transmitted.  ACK received.
 423   2            case SMB_MTADDACK:
 424   2            //SFRPAGE = SMB0_PAGE;
 425   2            SMB0DAT = RegAdd;          
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 8   

 426   2            break;
 427   2      
 428   2            // Master Transmitter: Slave address + WRITE transmitted.  NACK received.
 429   2            // The slave is not responding.  Send a STOP followed by a START to try again.
 430   2            case SMB_MTADDNACK:
 431   2            //SFRPAGE   = SMB0_PAGE;
 432   2                        STO = 1;
 433   2            STA = 1;
 434   2            break;
 435   2      
 436   2            // Master Transmitter: Data byte transmitted.  ACK received.
 437   2            // This state is used in both READ and WRITE operations.  Check BYTE_NUMBER
 438   2            // for memory address status - if only HIGH_ADD has been sent, load LOW_ADD.
 439   2            // If LOW_ADD has been sent, check COMMAND for R/W value to determine 
 440   2            // next state.
 441   2            case SMB_MTDBACK:
 442   2               switch (BYTE_NUMBER)
 443   2               {
 444   3                  case 2:                    // If BYTE_NUMBER=2, only HIGH_ADD
 445   3                       //SFRPAGE   = SMB0_PAGE;
 446   3                       if((RegAdd==0)||(RegAdd==2)||(RegAdd==4)||(RegAdd==6))
 447   3                              {
 448   4                              //WORDT = WORDT>>8;
 449   4                              SMB0DAT = (char)(WORD>>8);      // has been sent.
 450   4                              }else
 451   3      //               if((RegAdd==1)||(RegAdd==3)||(RegAdd==5)||(RegAdd==7))
 452   3      //                      {WORDT = WORD&0xFF;}
 453   3      //               WORD = (char)WORDT;
 454   3                     SMB0DAT = (char)WORD;      // has been sent.
 455   3                     BYTE_NUMBER--;          // Decrement for next time around.
 456   3                     break;
 457   3                  case 1:                    // If BYTE_NUMBER=1, LOW_ADD was just sent.
 458   3                     if (COMMAND & 0x01){    // If R/W=READ, sent repeated START.
 459   4                       //SFRPAGE   = SMB0_PAGE;
 460   4                                      STO = 0;
 461   4                        STA = 1;
 462   4                     } 
 463   3                     else { 
 464   4                          //SFRPAGE   = SMB0_PAGE;
 465   4      //                  if((RegAdd==0)||(RegAdd==2)||(RegAdd==4)||(RegAdd==6))
 466   4      //                      {WORDT = WORD&0xFF;}
 467   4                       if((RegAdd==0)||(RegAdd==2)||(RegAdd==4)||(RegAdd==6))
 468   4                              {
 469   5                              //WORDT = WORDT>>8;
 470   5                               SMB0DAT = (char)(WORD);      // If R/W=WRITE, load byte to write.
 471   5                              }else
 472   4      //                      WORDT = (char)WORDT; 
 473   4                            SMB0DAT = (char)(WORD>>8);      // If R/W=WRITE, load byte to write.
 474   4                        BYTE_NUMBER--;
 475   4                     }
 476   3               
 477   3                     break; 
 478   3                  case 0:                   // If BYTE_NUMBER=0, transfer is finished.
 479   3                   //SFRPAGE   = SMB0_PAGE;
 480   3                     STO = 1;
 481   3                     SM_BUSY = 0;            // Free SMBus
 482   3                  }
 483   2               break;
 484   2      
 485   2            // Master Transmitter: Data byte transmitted.  NACK received.
 486   2            // Slave not responding.  Send STOP followed by START to try again.
 487   2            case SMB_MTDBNACK:
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 9   

 488   2                //SFRPAGE   = SMB0_PAGE;
 489   2                STO = 1;
 490   2                STA = 1;
 491   2                break;
 492   2      
 493   2            // Master Transmitter: Arbitration lost.
 494   2            // Should not occur.  If so, restart transfer.
 495   2            case SMB_MTARBLOST:
 496   2              //SFRPAGE   = SMB0_PAGE; 
 497   2                          STO = 1;
 498   2              STA = 1;
 499   2              break;
 500   2      
 501   2            // Master Receiver: Slave address + READ transmitted.  ACK received.
 502   2            // Set to transmit NACK after next transfer since it will be the last (only)
 503   2            // byte.
 504   2            case SMB_MRADDACK:
 505   2              //SFRPAGE   = SMB0_PAGE;
 506   2                          //AA = 0;                       // NACK sent on acknowledge cycle.
 507   2              break;
 508   2       
 509   2            // Master Receiver: Slave address + READ transmitted.  NACK received.
 510   2            // Slave not responding.  Send repeated start to try again.
 511   2            case SMB_MRADDNACK:
 512   2               //SFRPAGE   = SMB0_PAGE;
 513   2                           STO = 0;
 514   2               STA = 1;
 515   2               break;
 516   2      
 517   2            // Data byte received.  ACK transmitted.
 518   2            // State should not occur because AA is set to zero in previous state.
 519   2            // Send STOP if state does occur.
 520   2            case SMB_MRDBACK:
 521   2               //SFRPAGE   = SMB0_PAGE;
 522   2               WORDR = SMB0DAT;
 523   2                           STO = 1;
 524   2               SM_BUSY = 0;
 525   2               break;
 526   2      
 527   2            // Data byte received.  NACK transmitted.
 528   2            // Read operation has completed.  Read data register and send STOP.
 529   2            case SMB_MRDBNACK:
 530   2               //SFRPAGE   = SMB0_PAGE;
 531   2                           STO = 1;
 532   2               SM_BUSY = 0;                  // Free SMBus
 533   2               break;
 534   2      
 535   2            // All other status codes meaningless in this application. Reset communication.
 536   2            default:
 537   2             //SFRPAGE   = SMB0_PAGE;
 538   2                   STO = 1;                      // Reset communication.
 539   2             SM_BUSY = 0;
 540   2             break;
 541   2            }
 542   1      
 543   1         SI=0;                               // clear interrupt flag
 544   1      }
 545          //------------------------------------------------------------------------------
 546          void delay1s(unsigned char U)
 547          { while (U)
 548   1              {delaynms(200);
 549   2                      delaynms(200);
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 10  

 550   2                      delaynms(200);
 551   2                      delaynms(200);
 552   2              delaynms(200);
 553   2                      U--;} }
 554          //------------------------------------------------------------------------------
 555          void delaynms (unsigned int uu)
 556          {  unsigned int oo,ll;
 557   1         for (oo=0;oo<uu;oo++)
 558   1         {for(ll=0;ll<1140;ll++);}}
 559          //------------------------------------------------------------------------------
 560          void delayn_ms (unsigned int uu)
 561          {  unsigned int oo,ll;
 562   1         for (oo=0;oo<uu;oo++) 
 563   1         {for(ll=0;ll<10;ll++);}}
 564          //------------------------------------------------------------------------------
 565          //buzzer 100ms per time
 566          //------------------------------------------------------------------------------
 567          void Buzz100ms(unsigned char u)
 568          { unsigned char i;
 569   1              for(i=0;i<u;i++)
 570   1              {       Buzz = 0;
 571   2                      delaynms(100);
 572   2                      Buzz = 1;
 573   2                      delaynms(100);}}
 574          //------------------------------------------------------------------------------
 575          //buzzer 1s per time
 576          //------------------------------------------------------------------------------
 577          void Buzz1s(unsigned char uuu)
 578          {
 579   1              unsigned char i;
 580   1              for(i=0;i<uuu;i++)
 581   1              {       
 582   2                      Buzz = 0;
 583   2                      delay1s(1);
 584   2                      Buzz = 1;
 585   2                      delay1s(1);
 586   2              }
 587   1      }
 588          //------------------------------------------------------------------------------
 589          
 590          ////-----------------------------------------------------------------------------
 591          ////显示函数
 592          ////-----------------------------------------------------------------------------
 593          void myshow(float testdata, unsigned char showadd)
 594          {     
 595   1                   unsigned char a[10]={0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39};
 596   1             int i=0;            
 597   1             int l=0,m=0,n=0,j=0,jj=0;  //l-百位, m-十位，n-个位，j-十分位小数,jj-百分位小数
 598   1             int h;                  //10-99.9的数扩大100倍
 599   1                   int t;                  //扩大100倍/10倍
 600   1                   int k;
 601   1                   
 602   1             unsigned char zl; 
 603   1                    
 604   1                if (testdata>=0 && testdata<=0.99)
 605   1                {  zl=showadd;          //ddram add                         
 606   2             wr_lcd(0,zl);
 607   2             delay(0x1); 
 608   2             
 609   2      //       zl=0x20;             //half space
 610   2      //       wrd(zl);
 611   2             
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 11  

 612   2             zl=0x30;             //0
 613   2             wr_lcd(1,zl);
 614   2             
 615   2             zl=0x2E;              //.   
 616   2             wr_lcd(1,zl);
 617   2             
 618   2             t=testdata*100;
 619   2             j=(int)t/10;
 620   2             wr_lcd(1,a[j]);
 621   2                         i=0; //<input type="hidden" >
 622   2                         
 623   2             jj=t%10;        
 624   2             wr_lcd(1,a[jj]); 
 625   2                   zl=zl;
 626   2               
 627   2                  }
 628   1          
 629   1          else if (testdata>=1 && testdata<=9.9)
 630   1               { zl=showadd;       //ddram add 
 631   2                wr_lcd(0,zl);
 632   2                delay(0x01);
 633   2                
 634   2                zl=0x20;          //half space
 635   2                wr_lcd(1,zl);
 636   2                
 637   2                t=testdata*10; 
 638   2                n=(int)t/10;
 639   2                wr_lcd(1,a[n]);
 640   2                i=0;              //i clear
 641   2                
 642   2                zl=0x2E;          //.
 643   2                wr_lcd(1,zl);        
 644   2              
 645   2                j=t%10;           //    
 646   2                          wr_lcd(1,a[j]); 
 647   2                          zl=zl;
 648   2                }
 649   1             
 650   1          
 651   1          else if (testdata>=10 && testdata<=99.90)
 652   1          {   
 653   2             zl=showadd;       //ddram add 
 654   2             wr_lcd(0,zl);
 655   2             delay(0x01);
 656   2             
 657   2             t=testdata*10;
 658   2                   m=(int)t/100;
 659   2             wr_lcd(1,a[m]);
 660   2             
 661   2             h=t%100;
 662   2             n=(int)h/10;
 663   2             wr_lcd(1,a[n]); 
 664   2           
 665   2             zl=0x2E;          //.
 666   2             wr_lcd(1,zl);
 667   2             
 668   2             j=h%10;
 669   2             wr_lcd(1,a[j]);
 670   2             zl=zl;
 671   2                 }
 672   1         
 673   1         else if (testdata>=100 && testdata<=199.9)
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 12  

 674   1              {zl=showadd;
 675   2                      wr_lcd(0,zl);
 676   2                      delay(0x01); 
 677   2                      
 678   2                      t=testdata*10;
 679   2                      l=(int)t/1000;
 680   2                      wr_lcd(1,a[l]);           //百位
 681   2                
 682   2                k=t%1000;
 683   2                      m=(int)k/100;
 684   2                      wr_lcd(1,a[m]);           //十位
 685   2                      
 686   2                      h=k%100;
 687   2                      n=(int)h/10;
 688   2                      wr_lcd(1,a[n]);           //个位
 689   2                      
 690   2                      zl=0x2E;          //.
 691   2            wr_lcd(1,zl);
 692   2            
 693   2            j=h%10;
 694   2            wr_lcd(1,a[j]);
 695   2            zl=zl;
 696   2          
 697   2                      }   
 698   1         
 699   1               
 700   1                else 
 701   1              {
 702   2               
 703   2               zl=0xB4;             //错
 704   2               wr_lcd(1,zl);
 705   2               zl=0xED;
 706   2               wr_lcd(1,zl);
 707   2               zl=0x21;             //！
 708   2               wr_lcd(1,zl);
 709   2               }
 710   1          }
 711          ////-----------------------------------------------------------------------------
 712          ////显示短路引脚函数
 713          ////-----------------------------------------------------------------------------
 714          void myshow_ShortPin(float testdata, unsigned char showadd)
 715          {     
 716   1                   unsigned char a[10]={0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39};
 717   1             int i=0;            
 718   1             int l=0,m=0,n=0,j=0,jj=0;  //l-百位, m-十位，n-个位，j-十分位小数,jj-百分位小数
 719   1             int h;                  //10-99.9的数扩大100倍
 720   1                   int t;                  //扩大100倍/10倍
 721   1                   //int k;
 722   1                   
 723   1             unsigned char zl; 
 724   1                    
 725   1                if (testdata>=0 && testdata<=0.99)                //值为0说明8脚短路，显示PIN8
 726   1                {                            
 727   2             zl=showadd;          //ddram add                         
 728   2             wr_lcd(0,zl);
 729   2             delay(0x1); 
 730   2             
 731   2      //       zl=0x20;             //half space`
 732   2      //       wrd(zl);
 733   2               
 734   2              zl=0x38;             //8
 735   2              wr_lcd(1,zl);
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 13  

 736   2              //Val_ShortPinNum2 = 8;  //置一下Val_ShortPinNum2,帮助显示Vprob时的标志位判断
 737   2             
 738   2      //       zl=0x30;             //0
 739   2      //       wr_lcd(1,zl);
 740   2      //       
 741   2      //       zl=0x2E;              //.   
 742   2      //       wr_lcd(1,zl);    
 743   2      //       
 744   2      //       t=testdata*100;
 745   2      //       j=(int)t/10;
 746   2      //       wr_lcd(1,a[j]);
 747   2      //                 i=0; 
 748   2      //                 
 749   2      //       jj=t%10;        
 750   2      //       wr_lcd(1,a[jj]); 
 751   2      //           zl=zl;
 752   2               
 753   2                  }
 754   1          
 755   1          else if (testdata>=1 && testdata<=9.9)
 756   1               {                                 
 757   2                zl=showadd;       //ddram add 
 758   2                wr_lcd(0,zl);
 759   2                delay(0x01);
 760   2                
 761   2      //        zl=0x20;          //half space
 762   2      //        WrData(zl);
 763   2                
 764   2                t=testdata*10; 
 765   2                n=(int)t/10;
 766   2                wr_lcd(1,a[n]);
 767   2                          i=0;              //i clear
 768   2                
 769   2      //        zl=0x2E;          //.
 770   2      //        wr_lcd(1,zl);             
 771   2      //      
 772   2      //        j=t%10;           //    
 773   2      //                  wr_lcd(1,a[j]); 
 774   2      //                  zl=zl;
 775   2                }
 776   1             
 777   1          
 778   1          else if (testdata>=10 && testdata<=99.90)
 779   1          {   
 780   2             zl=showadd;       //ddram add 
 781   2             wr_lcd(0,zl);
 782   2             delay(0x01);
 783   2             
 784   2                   t=testdata*10;
 785   2                   m=(int)t/100;
 786   2             wr_lcd(1,a[m]);
 787   2             
 788   2             h=t%100;
 789   2             n=(int)h/10;
 790   2             wr_lcd(1,a[n]); 
 791   2           
 792   2      //       zl=0x2E;          //.
 793   2      //       wr_lcd(1,zl);
 794   2      //       
 795   2      //       j=h%10;
 796   2      //       wr_lcd(1,a[j]);
 797   2      //       zl=zl;
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 14  

 798   2                 }
 799   1         
 800   1      //   else if (testdata>=100 && testdata<=199.9)
 801   1      //      {
 802   1      //              zl=showadd;
 803   1      //              wr_lcd(0,zl);
 804   1      //              delay(0x01); 
 805   1      //              
 806   1      //              t=testdata*10;
 807   1      //              l=(int)t/1000;
 808   1      //              wr_lcd(1,a[l]);           //百位
 809   1      //        
 810   1      //        k=t%1000;
 811   1      //              m=(int)k/100;
 812   1      //              wr_lcd(1,a[m]);           //十位
 813   1      //              
 814   1      //              h=k%100;
 815   1      //              n=(int)h/10;
 816   1      //              wr_lcd(1,a[n]);           //个位
 817   1      //              
 818   1      //              zl=0x2E;          //.
 819   1      //      wr_lcd(1,zl);
 820   1      //      
 821   1      //      j=h%10;
 822   1      //      wr_lcd(1,a[j]);
 823   1      //      zl=zl;
 824   1      //    
 825   1      //              }   
 826   1            
 827   1          else {zl=showadd;
 828   2               wr_lcd(0,zl);
 829   2               zl=0xB4;             //错
 830   2               wr_lcd(1,zl);
 831   2               zl=0xED;
 832   2               wr_lcd(1,zl);
 833   2               zl=0x21;             //！
 834   2               wr_lcd(1,zl);
 835   2               } 
 836   1      }
 837          //-----------------------------------------------------------------------------
 838          // ADC 
 839          //-----------------------------------------------------------------------------
 840          //void ADC (unsigned char Channel)
 841          //    {
 842          //      
 843          //      float  AD_VAL_TEST,AD_VAL;
 844          //      unsigned char xdata YYY;
 845          //      unsigned int xdata ad_arr[20];//,TempData;
 846          //              Channel_Select = Channel; 
 847          //                AMX0SL = Channel_Select;      // AMUX Channel Select Register
 848          //         //delaynms(5);
 849          //    AD_VAL=0;
 850          //    AD_VAL_TEST = 0;
 851          //    for( YYY = 0;YYY<20;YYY++) 
 852          //    {
 853          //    ad_arr[YYY]=0;
 854          //    } 
 855          //    YYY=0; 
 856          //    ADCINT = 0; 
 857          //    
 858          //    for(YYY= 0;YYY<20;YYY++)     //AD_TIMES=50  采50次
 859          //    {  
C51 COMPILER V7.50   天海                                                                  11/24/2010 09:52:46 PAGE 15  

 860          //    ADBUSY = 1;   
 861          // 
 862          //    delayn_ms(20);  ////////////---------------------------------------------------采样等待
 863          //    while (!ADCINT); 
 864          //        ADCINT = 0;   
 865          //    _nop_();
 866          //    _nop_();
 867          //    _nop_();             //*AD_POINTER = ADC0
 868          //    ad_arr[YYY]=ADC0;          
 869          //     }
 870          //    //ADC0 = 0; 
 871          //    for(YYY=0;YYY<20;YYY++) //  for(i = 0;i <AD_TIMES;i++)
 872          //      { 
 873          //              AD_VAL_TEST += ad_arr[YYY];
 874          //     }
 875          // 
 876          //      AD_VAL = (AD_VAL_TEST/20);     
 877          //      AD_VAL = AD_VAL/4096;
 878          //      AD_VAL = AD_VAL*2.43; 
 879          //      adtemp = AD_VAL;
 880          //       } 
 881          
 882          //-----------------------------------------------------------------------------
 883          void Clear()
 884          { Led = 1;
 885   1              Flag_Short = 0;
 886   1        Junc_Short = 0;
 887   1        Num_Short = 0;
 888   1              }
 889          
 890          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2279    ----
   CONSTANT SIZE    =     60    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24      95
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
